// Copyright 2023 Intrinsic Innovation LLC
// Intrinsic Proprietary and Confidential
// Provided subject to written agreement between the parties.

syntax = "proto3";

package intrinsic_proto.motion_planning;

import "intrinsic/icon/proto/joint_space.proto";
import "intrinsic/kinematics/ik/constrained/constrained_ik.proto";
import "intrinsic/math/proto/point.proto";
import "intrinsic/math/proto/pose.proto";
import "intrinsic/world/proto/object_world_refs.proto";

// Defines a cartesian target for a motion.
message CartesianMotionTarget {
  // The tool which you want to move.
  intrinsic_proto.world.TransformNodeReference tool = 1;
  // The frame with which you want to align the tool.
  intrinsic_proto.world.TransformNodeReference frame = 2;
  // Optional, you can place an offset between frame and tool. Defaults to the
  // Identity pose.
  //
  // This is frame_t_tool.
  intrinsic_proto.Pose offset = 3;
}

message CartesianWaypoints {
  // The frame on the tool that you want to move such that it aligns with the
  // waypoints.
  intrinsic_proto.world.TransformNodeReference tool = 1;
  // The frame in which the waypoints are specified.
  // Note that the frame is ignored if waypoints are only specified as joint
  // position vectors.
  intrinsic_proto.world.TransformNodeReference frame = 2;

  message Waypoint {
    oneof waypoint_kind {
      // Cartesian tool pose with respect to frame.
      intrinsic_proto.Pose frame_t_tool_offset = 1;

      // Joint position vector corresponding to the waypoint tool pose.
      intrinsic_proto.icon.JointVec joint_positions = 2;
    }
  }

  // A list of waypoints to pass through.
  repeated Waypoint waypoints = 6;

  // Radii of the circular blend around an intermediate waypoint in position
  // and rotation respectively. Both parameters should be positive and >= 0.001.
  // Default values of 0.001m and 0.01rad are used if these parameters are not
  // specified.
  optional double translational_rounding_m = 4;
  optional double rotational_rounding_rad = 5;
}

// Equality constraint enforcing that the position of the tool frame must match
// the desired frame location plus an optional offset between frame and the
// desired target position.
message PointConstraint {
  // The tool frame within the robot which you want to move.
  intrinsic_proto.world.TransformNodeReference tool = 1;
  // The target frame for which the position of the tool frame has to match.
  intrinsic_proto.world.TransformNodeReference frame = 2;
  // Optional, you can place an offset between frame and the desired target.
  optional intrinsic_proto.Point p_offset_in_frame = 3;
  // Maximum allowed position error, in meters. i.e. max l1-norm error.
  optional double max_position_error = 4;
}

// Equality constraint enforcing that the tool frame matches the desired frame
// with an optional offset between the 'frame' and the 'tool' frame.
message PoseConstraint {
  //  The tool frame within the robot which you want to move to a new target.
  intrinsic_proto.world.TransformNodeReference tool = 1;
  // The target frame with which you want to align the tool.
  intrinsic_proto.world.TransformNodeReference frame = 2;
  // Optional, you can place an offset between frame and tool. Defaults to
  // Identity pose.
  optional intrinsic_proto.Pose offset_in_frame = 3;
  // Maximum allowed position error, in meters. i.e. max l1-norm error, defaults
  // to 1e-4.
  optional double max_position_error = 4;
  // The maximum angle (in radians) between the orientation of the tip and
  // the orientation of the target pose. i.e. The constraint is satisfied if the
  // tip orientation can get aligned with the target orientation by doing a
  // rotation around some unspecified axis of an angle smaller or equal than
  // max_angle_deviation.
  optional double max_angle_deviation = 5;
}

// The constraint that a point P expressed in the 'tool' frame is contained
// inside an ellipsoid expressed in 'frame'. As an example, this
// constraint can be used to force that the tip of the chain reaches some target
// area. It allows frames to be constrained and can enforce that pairs of frames
// maintain a relative position difference.
message PositionEllipsoidConstraint {
  // The tool frame within the robot which you want to move to a new target.
  intrinsic_proto.world.TransformNodeReference tool = 1;
  // The target frame with which you want to align the tool.
  intrinsic_proto.world.TransformNodeReference frame = 2;
  // The pose, expressed in the 'frame', of the center of the ellipsoid
  // that point P needs to be contained in. The axes of the ellipsoid are
  // expressed in this frame.
  intrinsic_proto.Pose frame_t_ellipsoid_center = 3;
  // The ellipsoid half-axes in the frame of the ellipse.
  double rx = 4;
  double ry = 5;
  double rz = 6;
  // The point P, expressed in the 'tool' frame, that we want to constrain.
  // Defaults to zero.
  optional intrinsic_proto.Point p_offset_in_tool = 7;
  // Max position deviation in [m].
  optional double tolerance = 8;
}

// Defines a plane inequality constraint which forces the tool frame to stay on
// the side of the plane. The PlaneConstraint uses the coordinates of a point on
// the plane 'frame_p_point_on_plane' and the plane's normal expressed in the
// same frame 'plane_normal_in_frame'. The constraint will enforce that the
// tool frame origin (plus optional 'offset') lies on the side of the
// plane into which the normal vector points.
message PositionPlaneConstraint {
  // The tool frame within the robot which you want to move to a new target.
  intrinsic_proto.world.TransformNodeReference tool = 1;
  // The reference frame in which you define the plane.
  intrinsic_proto.world.TransformNodeReference frame = 2;
  // Plane definition expressed in reference frame
  intrinsic_proto.Point frame_p_point_on_plane = 3;
  intrinsic_proto.Point plane_normal_in_frame = 4;
  // Offset of target 'point' w.r.t to the 'tool' frame.
  optional intrinsic_proto.Point p_offset_in_tool = 5;
  // Max position deviation in [m].
  optional double tolerance = 6;
}

// Equality constraint which realizes a desired orientation of the end effector,
// but allows free rotation about a user-defined axis.
message PoseWithFreeAxisConstraint {
  // The tool frame within the robot which you want to move to a new target.
  intrinsic_proto.world.TransformNodeReference tool = 1;
  // The frame with which you want to align the tool.
  intrinsic_proto.world.TransformNodeReference frame = 2;
  // The unit vector that describes the free rotation axis in the frame.
  intrinsic_proto.Point target_axis_in_frame = 3;
  // Optional, you can place an offset between frame and tool.
  optional intrinsic_proto.Pose offset_in_frame = 4;
  // The (optional) maximum allowed position error, in meters. i.e. max l1-norm
  // error.
  optional double max_position_error = 5;
  // The (optional) maximum allowed angle between the two axes.
  optional double tolerance_rad = 6;
}

// Inequality constraint which aligns a user-definable axis of the end-effector
// with the given cone defined by target 'frame', the cone axis, and its opening
// angle.
message PoseConeConstraint {
  // The tool frame within the robot which you want to move to a new target.
  intrinsic_proto.world.TransformNodeReference tool = 1;
  // The frame with which you want to align the tool.
  intrinsic_proto.world.TransformNodeReference frame = 2;
  // The unit vector that describes the cone axis in the frame.
  intrinsic_proto.Point cone_axis_in_frame = 3;
  // Opening half-angle of the cone in radians.
  double cone_opening_half_angle_rad = 4;
  // Optional, you can place an offset between frame and tool.
  optional intrinsic_proto.Pose offset_in_frame = 5;
  // The (optional) maximum allowed position error, in meters. i.e. max l1-norm
  // error.
  optional double max_position_error = 6;
  // The (optional) maximum allowed violation of the maximum cone angle.
  optional double tolerance_rad = 7;
}

// A motion target constraint defined for a robot. This motion target is defined
// in the Cartesian space, but can be underconstrained.
message Constraint {
  string name = 1;
  oneof constraint {
    intrinsic_proto.kinematics.JointPositionLimitsConstraint
        joint_position_limits_constraint = 2;
    PointConstraint point_constraint = 3;
    PoseConstraint pose_constraint = 4;
    PositionPlaneConstraint plane_constraint = 5;
    PositionEllipsoidConstraint position_ellipsoid_constraint = 6;
    PoseWithFreeAxisConstraint orientation_free_axis_constraint = 7;
    PoseConeConstraint orientation_cone_constraint = 8;
  }
}

message ConstrainedMotionTarget {
  // A motion target constraint that defines the pose to which a frame in a
  // kinematic chain is suppose to move. This goal can be underconstrained.
  repeated Constraint constraints = 1;
}
