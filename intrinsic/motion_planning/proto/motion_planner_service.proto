// Copyright 2023 Intrinsic Innovation LLC

syntax = "proto3";

package intrinsic_proto.motion_planning;

import "intrinsic/geometry/proto/shape_data.proto";
import "intrinsic/icon/proto/cart_space.proto";
import "intrinsic/icon/proto/joint_space.proto";
import "intrinsic/kinematics/types/joint_limits.proto";
import "intrinsic/logging/proto/context.proto";
import "intrinsic/math/proto/pose.proto";
import "intrinsic/motion_planning/proto/motion_planner_config.proto";
import "intrinsic/motion_planning/proto/motion_specification.proto";
import "intrinsic/motion_planning/proto/motion_target.proto";
import "intrinsic/world/proto/collision_settings.proto";
import "intrinsic/world/proto/object_world_refs.proto";

// Different ways to specify a robot.
message RobotReference {
  oneof robot_reference {
    // Must have ObjectType==ROBOT_PART.
    intrinsic_proto.world.ObjectReference object_id = 1;
  }
}

// Robot specifications definitions
message RobotSpecification {
  // Specification of what robot is being controlled.
  RobotReference robot_reference = 1;

  // Starting joint configuration of the robot. If not set, the
  // current position in the world will be used.
  optional intrinsic_proto.icon.JointVec start_configuration = 2;

  // Default cartesian robot limits to apply to the motion.
  intrinsic_proto.icon.CartesianLimits default_cartesian_limits = 3;

  // Joint hardware (l1) limits of the robot. We can not exceed these limits.
  // Note that the field JointLimits.max_effort is not supported and will
  // always be filled with zeroes. If not specified, the default limits from
  // the world are used as the hardware limits.
  optional intrinsic_proto.JointLimits l1_joint_limits = 4;
}

message MotionPlanningRequest {
  string world_id = 1;

  // Defines robot and its parameters
  RobotSpecification robot_specification = 2;

  // Specifies the motion planning problem
  MotionSpecification motion_specification = 3;

  // Planner configuration. Default will set a timeout of 180 seconds for the
  // motion planning request.
  optional MotionPlannerConfiguration motion_planner_config = 4;

  // If set, a successful plan will also include the swept volume occupied by
  // the robot while performing the motion.
  bool compute_swept_volume = 5;
  // This id should be set ONLY by the motion planning service, and ONLY for the
  // purpose of logging.
  //
  // As worlds are mutable, we should not assume that the world of `world_id`
  // will be in the same state that it was at the time of this
  // PlanTrajectory call. If logging is turned on, the
  // MotionPlannerService will clone the world `world_id` and the id of the
  // cloned world will be stored here. Assuming nothing else decides to mutate
  // this cloned world, that world can be used as a reliable way to replicate
  // this planning call.
  string snapshot_world_id = 10;

  // An ID for identifying which skill/service sends this request.
  optional string caller_id = 6;

  // The logging context for the skill sending the request
  optional intrinsic_proto.data_logger.Context context = 7;
}

// Proto message to hold a `MotionPlanningRequestCacheKey` for logging.
message MotionPlanningRequestCacheKey {
  repeated string object_and_frame_names = 1;
  repeated intrinsic_proto.Pose object_and_frame_poses = 2;
  RobotSpecification robot_specification = 3;
  MotionSpecification motion_specification = 4;
  optional MotionPlannerConfiguration motion_planner_config = 5;
  intrinsic_proto.icon.JointVec starting_robot_configuration = 6;
  // Currently RuleSet message is not externalized. Skip it for now.
  string uuid = 8;
}

message CacheKeyMatchInfo {
  string given_cache_key_uuid = 1;
  string matched_cache_key_uuid = 2;
}

message TrajectoryPlanningResponse {
  oneof trajectory {
    intrinsic_proto.icon.JointTrajectoryPVA discretized = 1;
  }

  // If requested, these shapes represent the swept volume generated by the
  // input robot performing the computed path.
  repeated intrinsic_proto.geometry.ShapeData swept_volume = 2;
}

message IkRequest {
  string world_id = 1;

  CartesianMotionTarget target = 2;

  // [Optional] Starting joint configuration, used to seed the Ik. If not set,
  // the current position in the world will be used.
  intrinsic_proto.icon.JointVec starting_joints = 3;

  // Specification of what robot is being controlled.
  RobotReference robot_reference = 4;

  // The maximum number of solutions to be returned. If not set (== 0), the
  // underlying implementation has the freedom to choose. Negative values are
  // invalid.
  //
  // Choosing a smaller value may make some implementations faster, but this
  // depends on the underlying implementation and is not guaranteed.
  int32 max_num_solutions = 5;

  // If this field is left unset, no collision checking will take place.
  // Otherwise, only collision-free solutions are returned.
  intrinsic_proto.world.CollisionSettings collision_settings = 6;

  // Specify whether to compute an IK solution which is on the same kinematic
  // branch as the current state of the robot in the world or as the starting
  // joints, if specified. Defaults to false.
  optional bool ensure_same_branch = 7;
}

message IkResponse {
  // Solutions will be sorted by distance away from the joint values in the
  // request.
  repeated intrinsic_proto.icon.JointVec solutions = 1;
}

message FkRequest {
  string world_id = 1;

  // Joints to set for the robot. If not set, the current position in the world
  // will be used.
  intrinsic_proto.icon.JointVec joints = 2;

  // Specification of what robot is being controlled.
  RobotReference robot_reference = 3;

  // The returned transform is reference_t_target, i.e. the frame of "target" in
  // the frame of "reference".
  //
  // Typically, some of the joints of "robot_reference" should lie inbetween the
  // these two frames, otherwise you wouldn't see any changes to the returned
  // transform.
  //
  // As an example, "reference" could be the base link of a robot, and target
  // might be the robot's end-effector.
  intrinsic_proto.world.TransformNodeReference reference = 4;
  intrinsic_proto.world.TransformNodeReference target = 5;
}

message FkResponse {
  intrinsic_proto.Pose reference_t_target = 3;
}

message CheckCollisionsRequest {
  string world_id = 1;

  // Specification of what robot is being controlled.
  RobotReference robot_reference = 2;

  // The path to be collision checked. We assume the robot travels linearly (in
  // joint space) between each of the specified waypoints. If you want to
  // collision check a non-point-to-point trajectory with this function, you
  // must discritize it finely enough.
  repeated intrinsic_proto.icon.JointVec waypoint = 3;

  intrinsic_proto.world.CollisionSettings collision_settings = 4;
}

message CheckCollisionsResponse {
  bool has_collision = 1;
  // Implementation defined message to help the caller understand the collision.
  string collision_debug_msg = 2;
}

message ClearCacheRequest {}
message ClearCacheResponse {}

service MotionPlannerService {
  // Plans a trajectory that fulfills the defined motion specification in the
  // MotionPlannerRequest.
  rpc PlanTrajectory(MotionPlanningRequest)
      returns (TrajectoryPlanningResponse) {}

  // Computes IK for the robot.
  rpc ComputeIk(IkRequest) returns (IkResponse) {}

  // Computes FK for the robot.
  rpc ComputeFk(FkRequest) returns (FkResponse) {}

  // Collision-checks a specified path.
  rpc CheckCollisions(CheckCollisionsRequest)
      returns (CheckCollisionsResponse) {}

  // Clear cache for PlanTrajectory.
  rpc ClearCache(ClearCacheRequest) returns (ClearCacheResponse) {}
}
