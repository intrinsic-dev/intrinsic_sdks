// Copyright 2023 Intrinsic Innovation LLC

syntax = "proto3";

package intrinsic_proto.motion_planning;

import "google/protobuf/empty.proto";
import "intrinsic/geometry/proto/shape_data.proto";
import "intrinsic/icon/proto/joint_space.proto";
import "intrinsic/logging/proto/context.proto";
import "intrinsic/math/proto/pose.proto";
import "intrinsic/motion_planning/proto/motion_planner_config.proto";
import "intrinsic/motion_planning/proto/motion_specification.proto";
import "intrinsic/motion_planning/proto/robot_specification.proto";
import "intrinsic/world/proto/collision_settings.proto";
import "intrinsic/world/proto/geometric_constraints.proto";
import "intrinsic/world/proto/object_world_refs.proto";

message MotionPlanningRequest {
  // The id of the world to be used for motion planning.
  string world_id = 1;

  // Defines the robot for which the motion is planned and its parameters.
  RobotSpecification robot_specification = 2;

  // Specifies the motion planning problem to be solved.
  MotionSpecification motion_specification = 3;

  // Planner specific configuration. Default will set a timeout of 90 seconds
  // for the motion planning request.
  optional MotionPlannerConfiguration motion_planner_config = 4;

  // If set, a successful plan will also include the swept volume occupied by
  // the robot while performing the motion.
  bool compute_swept_volume = 5;

  // This id should be set ONLY by the motion planning service, and ONLY for the
  // purpose of logging.
  // As worlds are mutable, we should not assume that the world of `world_id`
  // will be in the same state that it was at the time of this
  // motion planning call. If logging is turned on, the
  // MotionPlannerService will clone the world `world_id` and the id of the
  // cloned world will be stored here. Assuming nothing else mutates the
  // cloned world, that world can be used as a reliable way to replicate
  // this planning call.
  string snapshot_world_id = 10;

  // An ID for identifying which skill/service sends this request.
  optional string caller_id = 6;

  // The logging context for the skill sending the request.
  optional intrinsic_proto.data_logger.Context context = 7;
}

message TrajectoryPlanningResponse {
  oneof trajectory {
    // The computed discretized trajectory that can be executed by the input
    // robot.
    intrinsic_proto.icon.JointTrajectoryPVA discretized = 1;
  }

  // If requested, these shapes represent the swept volume generated by the
  // input robot performing the computed trajectory.
  repeated intrinsic_proto.geometry.ShapeData swept_volume = 2;
}

message IkRequest {
  // The id of the world to be used for Inverse Kinemetics (IK) computation.
  string world_id = 1;

  // The Cartesian motion target constraint for which we want to compute a joint
  // configuration that satisfies those constraints.
  intrinsic_proto.world.geometric_constraints.GeometricConstraint target = 2;

  // [Optional] Joint configuration, used to seed the Ik. If not set,
  // the current position in the world will be used.
  intrinsic_proto.icon.JointVec starting_joints = 3;

  // Specification of what robot is being controlled.
  RobotReference robot_reference = 4;

  // The maximum number of solutions to be returned. If not set (== 0), the
  // underlying implementation has the freedom to choose. Negative values are
  // invalid.
  // Choosing a smaller value may make some implementations faster, but this
  // depends on the underlying implementation and is not guaranteed.
  int32 max_num_solutions = 5;

  // If this field is left unset, no collision checking will take place.
  // Otherwise, only collision-free solutions are returned.
  intrinsic_proto.world.CollisionSettings collision_settings = 6;

  // Specify whether to compute an IK solution which is on the same kinematic
  // branch as the `starting_joints` configuration of the robot. Defaults to
  // false.
  optional bool ensure_same_branch = 7;

  // Optional same branch Ik flag that will prefer solutions on the same
  // kinematic branch over those close to the `starting_joints` configuration.
  // Defaults to false.
  optional bool prefer_same_branch = 9;
}

message IkResponse {
  // Robot joint configuration that satisfy the Cartesian target constraint
  // specified in the request. Solutions will be sorted by distance away from
  // the joint values in the request. If `prefer_same_branch` is set, the first
  // solution will correspond to the soluiton on the same branch, if such
  // solution exists.
  repeated intrinsic_proto.icon.JointVec solutions = 1;
}

message FkRequest {
  // The id of the world to be used for the Forward Kinematic (FK) computation.
  string world_id = 1;

  // Joints to set for the robot. If not set, the current position in the world
  // will be used.
  intrinsic_proto.icon.JointVec joints = 2;

  // Specification of what robot is being controlled.
  RobotReference robot_reference = 3;

  // The reference frame for which the Cartesian pose is computed. The returned
  // transform is reference_t_target, i.e. the frame of `target` in the frame
  // of `reference`. Typically, some of the joints of `robot_reference` should
  // lie in between these two frames, otherwise you wouldn't see any changes
  // to the returned transform.
  // As an example, `reference` could be the base link of a robot, and target
  // might be the robot's end-effector.
  intrinsic_proto.world.TransformNodeReference reference = 4;

  // The target frame for which the Cartesian pose is computed. The returned
  // transform is reference_t_target, i.e. the frame of `target` in the frame
  // of `reference`. Typically, some of the joints of `robot_reference` should
  // lie inbetween the these two frames, otherwise you wouldn't see any changes
  // to the returned transform.
  // As an example, `reference` could be the base link of a robot, and target
  // might be the robot's end-effector.
  intrinsic_proto.world.TransformNodeReference target = 5;
}

message FkResponse {
  // Cartesian pose of the `target` frame expressed in the `reference` frame.
  intrinsic_proto.Pose reference_t_target = 3;
}

message CheckCollisionsRequest {
  // The id of the world to be used for the collision check.
  string world_id = 1;

  // Specification of what robot is being controlled.
  RobotReference robot_reference = 2;

  // The path of the robot specified in `robot_reference` to be collision
  // checked. We assume the robot travels linearly (in joint space) between each
  // of the specified waypoints. If you want to collision check a
  // non-point-to-point trajectory with this function, you must discritize it
  // finely enough.
  repeated intrinsic_proto.icon.JointVec waypoint = 3;

  // Collision settings to applied during collision checking. If not defined,
  // the default setting with zero margin will be applied.
  intrinsic_proto.world.CollisionSettings collision_settings = 4;
}

message CheckCollisionsResponse {
  // Whether the checked path is in collision or not.
  bool has_collision = 1;
  // Message to help the caller understand the collision that occurred. Note,
  // that this message only lists the first collision encountered. There may
  // be more collisions.
  string collision_debug_msg = 2;
}

// The Motion Planner Service provides motion planning and related operations,
// such as kinematics and collision checking. It is used by skills such as
// `Move Robot` and is available by thid party skills and services.
service MotionPlannerService {
  // Plans a trajectory that fulfills the defined motion specification in the
  // MotionPlannerRequest. Requests are cached in a volatile cache, if the
  // service encounters identical requests it will return previously cached
  // solutions. The cache can be cleared by either restarting the service or
  // calling `ClearCache`.
  rpc PlanTrajectory(MotionPlanningRequest)
      returns (TrajectoryPlanningResponse) {}

  // Computes the Inverse Kinematics (IK) for the robot, i.e. the robots joint
  // configuration that satisfy the set of Cartesian constraints.
  rpc ComputeIk(IkRequest) returns (IkResponse) {}

  // Computes the Forward Kinematic (FK), i.e., the Cartesian pose of a target
  // frame with respect to a reference, for a given joint configuration of a
  // robot.
  rpc ComputeFk(FkRequest) returns (FkResponse) {}

  // Collision-checks a specified path.
  rpc CheckCollisions(CheckCollisionsRequest)
      returns (CheckCollisionsResponse) {}

  // PlanTrajectory uses caching to speed up repeated similar planning calls.
  // Clear cache for PlanTrajectory.
  rpc ClearCache(google.protobuf.Empty) returns (google.protobuf.Empty) {}
}
